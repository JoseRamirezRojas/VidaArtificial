/* autogenerated by Processing revision 1286 on 2022-11-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class RBN extends PApplet {

/**
 Abstraccion de un automata celular
 
 Jose David Ramirez Rojas
 */
class RBNet {

  int[] celdas;  
  int[] reglas; 
  int[][] red;
  int generacion;
  boolean generacionMutada;
  int nodoMutado;

  RBNet(int[] rules, int[][] network) {
    reglas = rules;
    red = network;
    celdas = new int[20];  // hay 20 celdas, cada una es el estado de un nodo de la red
    generacionMutada = false;
    nodoMutado = 9999;
    restart();
  }
  
   public void randomizeRules() {
    for (int i = 0; i < 8; i++) {
      reglas[i] = PApplet.parseInt(random(2)); // aleatorizamos el valor de las reglas
    }
  }
  
   public void randomizeNet() {
    for (int i = 0; i < 20; i++) 
      for (int j = 0; j < 4; j++)
        if (j == 0)
          red[i][j] = PApplet.parseInt(random(2)); // aleatorizamos el valor inicial del nodo
        else
          red[i][j] = PApplet.parseInt(random(20)); // aleatorizamos las referencias a otros nodos
  }
  
   public void restart() {
    for (int i = 0; i < 20; i++)
      celdas[i] = red[i][0];
      
    generacion = 0;
  }
  
   public void render() {
    for (int i = 0; i < celdas.length; i++) {
      if (generacionMutada && i == nodoMutado && celdas[i] == 1){
        fill(204, 2, 0);
      }
      else if (generacionMutada && i == nodoMutado && celdas[i] == 0){
        fill(0, 2, 204);
      }
      else if (celdas[i] == 1) {
        fill(250);  // llenamos con blanco con donde el automata sea 1
      } else { 
        fill(10);  //llenamos con negro (gris oscuro)
      } 
      rect(generacion * 15, i * 25, 15, 25); // dibujamos la celda en las posiciones (x,y) = (i,generacion) con alto y ancho = 25 x 15
    }
  }

   public void generate() {
    int[] nextGen = new int[20]; //creamos una nueva generacion
    float prob = random(1);
    if (prob > 0.92f)
      generacionMutada = true;
    else
      generacionMutada = false;
    if(generacionMutada){
      nodoMutado = PApplet.parseInt(random(20));
    }
    for (int i = 0; i < 20; i++) { 
      // empezando por la segunda celda hasta la penultima vemos los vecinos
      int edge1 = red[i][1];   
      int edge2 = red[i][2];       
      int edge3 = red[i][3]; 
      if (red[edge1][0] == 0 && red[edge2][0] == 0 && red[edge3][0] == 0) { nextGen[i] = reglas[0]; }
      if (red[edge1][0] == 0 && red[edge2][0] == 0 && red[edge3][0] == 1) { nextGen[i] = reglas[1]; }
      if (red[edge1][0] == 0 && red[edge2][0] == 1 && red[edge3][0] == 0) { nextGen[i] = reglas[2]; }
      if (red[edge1][0] == 0 && red[edge2][0] == 1 && red[edge3][0] == 1) { nextGen[i] = reglas[3]; }
      if (red[edge1][0] == 1 && red[edge2][0] == 0 && red[edge3][0] == 0) { nextGen[i] = reglas[4]; }
      if (red[edge1][0] == 1 && red[edge2][0] == 0 && red[edge3][0] == 1) { nextGen[i] = reglas[5]; }
      if (red[edge1][0] == 1 && red[edge2][0] == 1 && red[edge3][0] == 0) { nextGen[i] = reglas[6]; }
      if (red[edge1][0] == 1 && red[edge2][0] == 1 && red[edge3][0] == 1) { nextGen[i] = reglas[7]; }
      
      if (generacionMutada && i == nodoMutado) { // checamos si hay gen mutado esta generación
        nextGen[i] = (nextGen[i] + 1) % 2;
      }
    }
    for (int i = 0; i < 20; i++) {  
      celdas[i] = nextGen[i];
      red[i][0] = nextGen[i];
    }  
    generacion++;
  }
  
   public boolean lastGen() {
    if (generacion > width) {
       return true; // paramos con tantas generaciones como la pantalla permita
    } else {
       return false;
    }
  }
}
/**
 * Ejecución de Random Boolean Network de Stuart A.Kauffman 
 * 
 * Permite guardar una imagen con una RBN generada aleatoriamente
 */
 
RBNet net; 
PrintWriter output;

 public void setup() {
  /* size commented out by preprocessor */;
  frameRate(24);
  int[] rules = new int[8]; 
  int[][] network = new int[20][4]; 
   for (int i = 0; i < 8; i++) {
      rules[i] = PApplet.parseInt(random(2)); // aleatorizamos el valor de la regla inicial
    }
  for (int i = 0; i < 20; i++) 
      for (int j = 0; j < 4; j++)
        if (j == 0)
          network[i][j] = PApplet.parseInt(random(2)); // aleatorizamos el valor inicial del nodo
        else
          network[i][j] = PApplet.parseInt(random(20)); // aleatorizamos las referencias a otros nodos  
  net = new RBNet(rules, network);  
  background(0);
  output = createWriter("regla_usada.txt");
}

 public void draw() {
  net.render();  // dibujamos 
  net.generate();  // creamos nuevas generaciones
  
  if(net.lastGen()){
    // si se deja correr la animacion hasta la última generacion se guarda la imagen del automata
    save("random_boolean_net.jpg");  
    noLoop(); // detenemos la generación
    // reportamos que regla se usó en el automata generado
    output.println("000 -> " + net.reglas[0]);
    output.println("001 -> " + net.reglas[1]);
    output.println("010 -> " + net.reglas[2]);
    output.println("011 -> " + net.reglas[3]);
    output.println("100 -> " + net.reglas[4]);
    output.println("101 -> " + net.reglas[5]);
    output.println("110 -> " + net.reglas[6]);
    output.println("111 -> " + net.reglas[7]); 
    output.flush();  // escribimos y guardamos al archivo
    output.close(); // cerramos el archivo
  }
    
}

 public void mousePressed() {
  background(0);
  net.randomizeRules();
  net.randomizeNet();
  net.restart(); // al hacer clic se genera otro automata con otras reglas (aleatorias)
  output = createWriter("regla_usada.txt"); //reabrimos el archivo para escribir la nueva regla
  loop(); //reanudamos el método draw()
}


  public void settings() { size(1170, 550); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "RBN" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
